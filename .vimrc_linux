"augroup ReloadVimrc
"autocmd!
"autocmd BufWritePost ~/.vimrc source ~/.vimrc
"augroup END

if exists('$VIM_TERMINAL')
  echoerr 'Do not run Vim inside a Vim terminal'
  quit
endif

" Basic config
set nu
set relativenumber
set ignorecase

set nocompatible

set termguicolors
set bg=dark
"let g:gruvbox_contrast_dark=soft
let g:gruvbox_invert_tabline=1
let g:gruvbox_invert_signs = 1
let g:gruvbox_improved_warnings=1
let g:gruvbox_improved_strings=1

"colorscheme sorbet
"colorscheme habamax
colorscheme gruvbox

syntax on
nnoremap <C-Q> :q<CR>
nnoremap <leader>sv :source ~/.vimrc<CR>
nnoremap <silent> <C-L> :nohlsearch<CR><C-L>

set enc=utf-8
source $VIMRUNTIME/vimrc_example.vim

" 开关撤销树的键映射
nnoremap <F2>      :UndotreeToggle<CR>
inoremap <F2> <C-O>:UndotreeToggle<CR>

if has('mouse')
  if has('gui_running') || (&term =~ 'xterm' && !has('mac'))
    set mouse=a
  else
    set mouse=nvi
  endif
endif

set nobackup

if has('persistent_undo')
  set undofile
  set undodir=~/.vim/undodir
  if !isdirectory(&undodir)
    call mkdir(&undodir, 'p', 0700)
  endif
endif

source $VIMRUNTIME/ftplugin/man.vim
set keywordprg=:Man

let do_syntax_sel_menu = 1
let do_no_layload_menus = 1

"if has("gui_running")
"    set lines=38 columns=129
"endif

" Copy and paste with system clipboard
if has('gui_running')
  nnoremap <C-S-V> "+gP
  inoremap <C-S-V> <Esc>"+gpi
  vnoremap <C-S-C> "+y
  cnoremap <C-S-V> <C-r>+
  "tnoremap <Esc><Esc> <C-\><C-n>
else
  nnoremap <C-V> <C-V>
endif

tnoremap <Esc><Esc> <C-W>N
tnoremap <C-A> <C-W>.

" Indent settings
au FileType c,cpp,objc  setlocal expandtab shiftwidth=4 softtabstop=4 tabstop=4 cinoptions=:0,g0,(0,w1
au FileType json        setlocal expandtab shiftwidth=2 softtabstop=2
au FileType vim         setlocal expandtab shiftwidth=2 softtabstop=2


if exists('*minpac#init')
  " Minpac is loaded.
  call minpac#init()
  call minpac#add('k-takata/minpac', {'type': 'opt'})

  " Other plugins
  call minpac#add('tpope/vim-eunuch')
  call minpac#add('yegappan/mru')
  call minpac#add('majutsushi/tagbar')
  call minpac#add('FittenTech/fittencode.vim')
  "call minpac#add('github/copilot.vim')
  call minpac#add('mbbill/undotree')
  call minpac#add('tpope/vim-surround')
  call minpac#add('preservim/nerdtree')
  call minpac#add('jiangmiao/auto-pairs')
  call minpac#add('tpope/vim-repeat')
  call minpac#add('junegunn/fzf', {'do': {-> fzf#install()}})
  call minpac#add('junegunn/fzf.vim')
  call minpac#add('tpope/vim-commentary')
  call minpac#add('preservim/nerdcommenter')
  call minpac#add('vim-airline/vim-airline')
  call minpac#add('vim-airline/vim-airline-themes')
  call minpac#add('tpope/vim-fugitive')
  call minpac#add('vimwiki/vimwiki')
  call minpac#add('frazrepo/vim-rainbow')
  call minpac#add('vim-autoformat/vim-autoformat')
  call minpac#add('machakann/vim-swap')
  call minpac#add('nanotech/jellybeans.vim')
  call minpac#add('morhetz/gruvbox')
  call minpac#add('vim-scripts/SyntaxAttr.vim')
  call minpac#add('octol/vim-cpp-enhanced-highlight')
  call minpac#add('skywind3000/asyncrun.vim')
  call minpac#add('puremourning/vimspector')
  call minpac#add('vim-scripts/matrix.vim--Yang')
  call minpac#add('drmikehenry/vim-fontsize')


endif

if has('eval')
  " Minpac commands
  command! PackUpdate packadd minpac | source $MYVIMRC | call minpac#update('', {'do': 'call minpac#status()'})
  "command! PackUpdate source $MYVIMRC | call PackInit() | call minpac#update()
  command! PackClean  packadd minpac | source $MYVIMRC | call minpac#clean()
  command! PackStatus packadd minpac | source $MYVIMRC | call minpac#status()
endif

"set completeopt=menuone,popup
" YCM config
let g:ycm_autoclose_preview_window_after_insertion = 1
let g:ycm_autoclose_preview_window_after_completion = 1
let g:ycm_complete_in_comments = 1
let g:ycm_key_invoke_completion = '<C-Z>'
let g:ycm_auto_trigger = 1
let g:ycm_always_populate_location_list = 1

"let g:ycm_min_num_identifier_candidate_chars = 1
let g:ycm_clangd_uses_ycmd_caching = 0

let g:ycm_complete_in_strings = 1

" When the cursor hover on a type
let g:ycm_auto_hover=''
nmap <leader>dt <plug>(YCMHover)

nnoremap <Leader>fi :YcmCompleter FixIt<CR>
nnoremap <Leader>gt :YcmCompleter GoTo<CR>
nnoremap <Leader>gd :YcmCompleter GoToDefinition<CR>
nnoremap <Leader>gh :YcmCompleter GoToDeclaration<CR>
nnoremap <Leader>gr :YcmCompleter GoToReferences<CR>
nnoremap <Leader>rr :YcmCompleter RefactorRename<SPACE>

set tags=./tags;,tags,/usr/local/etc/systags

" Tagbar
" 开关 Tagbar 插件的键映射
nnoremap <F10>      :TagbarToggle<CR>
inoremap <F10> <C-O>:TagbarToggle<CR>

" Fitten code
"let g:fitten_trigger="\<C-l>"
let g:fitten_accept_key="\<C-j>"

" imap <C-J> <C-r>=FittenAccept()<CR>


" Copilot
"let g:copilot_proxy = 'http://10.0.2.2:7890'
"imap <silent><script><expr> <C-J> copilot#Accept("\<CR>")
"let g:copilot_no_tab_map = v:true
"imap <C-L> <Plug>(copilot-accept-word)

function! JumpAndReturn()
  " 保存当前窗口编号
  let l:current_win = winnr()
  " 执行正常的跳转
  execute "normal! \<CR>"
  " 返回原窗口 - 使用 l: 前缀确保是局部变量
  execute l:current_win . "wincmd w"
endfunction
autocmd FileType qf nnoremap <buffer> p :call JumpAndReturn()<CR>

" NerdTree
nnoremap <F9> :NERDTreeToggle<CR>
inoremap <F9> <C-O>:NERDTreeToggle<CR>
" Exit Vim if NERDTree is the only window remaining in the only tab.
autocmd BufEnter * if tabpagenr('$') == 1 && winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | call feedkeys(":quit\<CR>:\<BS>") | endif

" scrolloff
set scrolloff=0

" move the lines
nnoremap <silent><A-j> :m .+1<CR>==
nnoremap <silent><A-k> :m .-2<CR>==

vnoremap <silent><A-j> :m '>+1<CR>gv=gv
vnoremap <silent><A-k> :m '<-2<CR>gv=gv

" Quick split a line or word with a new line
nnoremap <Leader><CR> i<CR><ESC>l

" Udowarning
let g:undofile_warn_mode=2

packadd termdebug

" F7: Step Over (executes function calls without entering them)
nnoremap <F7> :Over<CR>

" F6: Step Into (enters function calls)
nnoremap <F6> :Step<CR>

" F5 Add an breakpoint
nnoremap <F5> :Break<CR>

let g:termdebug_wide = 1

augroup TermdebugResize
  " Clear any old autocommands in this group to prevent duplicates
  autocmd!

  " When a file of type 'gdb' is opened (like Termdebug's GDB window)...
  " ...set its width to 45 columns.
  autocmd FileType termdebug vertical resize 46 | resize 10
augroup END

nnoremap <Leader>t :botright terminal ++rows=15<CR>
nnoremap <Leader>nt :tabe \| ter ++curwin<CR>

" Set fold method
set foldmethod=syntax
set foldlevelstart=99

" Mappings in terminal mode
tnoremap <C-S-V> <C-W>"+

" Airline
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#show_tab_nr = 1
let g:airline#extensions#tabline#tab_nr_type = 1
"let g:airline#extensions#tabline#tabnr_formatter = 'tabnr'
let g:airline#extensions#tabline#show_splits = 0
let g:airline#extensions#tabline#show_buffers = 0
let g:airline#extensions#tabline#buffer_nr_show = 0
let g:airline_powerline_fonts = 1
let g:airline#extensions#tabline#formatter = 'unique_tail'
"let g:airline_theme='zenburn'
let g:airline_theme='gruvbox'
let g:airline#extensions#ycm#enabled = 1

"Close gvim menubar and toolbar, set font in gvim
if has('gui_running')
  set guioptions-=m
  set guioptions-=T
  set guifont=Monospace\ 11
endif

" Undo in insert mode
inoremap <C-R> <C-G>u<C-R>
inoremap <C-W> <C-G>u<C-W>
inoremap <C-U> <C-G>u<C-U>

noremap <leader>rb :RainbowToggle<CR>

if v:version >= 800
  packadd! editexisting
endif

" Found the previous or next error in quickfix window
"nnoremap<F11> :lpr<CR>
nnoremap<F11> :cp<CR>
"nnoremap<F12> :lne<CR>
nnoremap<F12> :cn<CR>

" Close a tab by middle button of mouse
noremap <MiddleMouse> :tabclose<CR>

" switch among the tabs
nnoremap<C-Tab> gt
nnoremap<C-S-Tab> gT

" Vimwiki
let g:vimwiki_list = [{'path': '~/vimwiki/',
      \ 'syntax': 'markdown', 'ext': 'md'}]

let g:formatters_vue = []
"Auto-formatter
let g:autoformat_verbosemode=1
nnoremap <F3> :Autoformat<CR>
xnoremap <F3> :Autoformat<CR>
"nnoremap <Leader>ff :AutoformatLine<CR>
nnoremap <silent><Space> :AutoformatLine<CR>
xnoremap <Leader>ff :AutoformatLine<CR>

set cursorline

"quickly compile C++ code
"nnoremap <F8> :execute 'botright terminal ' . findfile('compile.sh', expand('%:p:h') . ';') . ' %:t -o %:r'<CR>
"nnoremap <Leader>rn :execute 'botright terminal ' . './%:r'<CR>
nnoremap <silent> <Leader>rn :update<CR> :call CompileAndRun()<CR>

function! CompileAndRun()
  " 1. Save the current file's name BEFORE opening any terminal
  let l:current_file_name = expand('%:t')    " e.g., myprogram.c
  let l:current_file_root = expand('%:t:r')    " e.g., myprogram
  let l:current_file_path = expand('%:p:h')  " e.g., /home/user/myproject

  echo l:current_file_root

  let l:compile_script = findfile('compile.sh', l:current_file_path . ';')
  let l:compile_script = fnamemodify(l:compile_script, ':p')
  " echo 'File found: ' . l:compile_script
  if empty(l:compile_script)
    echoerr "compile.sh not found in " . l:current_file_path . " or parent directories!"
    return
  endif

  " 2. Combine compile and run commands into a single string
  " Use && to ensure run only happens if compile exits successfully (0 status)
  let l:compile_command = l:compile_script . ' ' . l:current_file_name . ' -o ' . l:current_file_root
  "let l:run_command = './' . l:current_file_root
  let l:run_command = ''

  " Check if the path starts with '/' (absolute path)
  if strridx(l:current_file_root, '/', 0) == 0
    let l:run_command = l:current_file_root
  " Check if the path starts with './' or '../' (already relative)
  elseif strridx(l:current_file_root, './', 0) == 0 || strridx(l:current_file_root, '../', 0) == 0
    let l:run_command = l:current_file_root
  " Otherwise, it's a relative path without explicit prefix, so add './'
  else
    let l:run_command = './' . l:current_file_root
  endif

  " Command to execute in the terminal
  " We use 'cd' to ensure the run command executes in the correct directory
  " This assumes compile.sh also handles its paths correctly or changes directory if needed.
  " let l:full_terminal_command = 'cd ' . shellescape(l:current_file_path) . ' && ' . l:compile_command . ' && ' . l:run_command
  let l:full_terminal_command = 'cd ' . shellescape(l:current_file_path) .
        \' && if (' . l:compile_command . '); then (' . l:run_command . '); fi'

  " <--- ADD THIS LINE TO PRINT THE COMMAND ---
  "echo l:current_file_root
  "let l:log_file = '/home/zomjie/Study/LearnCpp/vimlog' " Choose a suitable path
  "call writefile(['Executing command: ' . l:full_terminal_command], l:log_file, 'a') " 'a' appends
  " ------------------------------------------

  " 3. Execute the combined command in a single terminal pane
  "execute 'botright terminal ' . &shell . ' -c "' . l:full_terminal_command . '"'
  execute 'botright terminal ++shell ++noclose ++eof=keep'  l:full_terminal_command
  setlocal nonumber
  setlocal norelativenumber
endfunction

let g:ctrlspace_use_tabline = 0

" Avoid to insert `;2u` int terminal mode when pressing Shift+Space
tnoremap <S-Space> <Space>

" Set the highlight for the terminal buffer
let g:terminal_ansi_colors = [
      \'#282828', '#CC241D', '#98971A', '#D79921',
      \'#458588', '#B16286', '#689D6A', '#D65D0E',
      \'#fb4934', '#b8bb26', '#fabd2f', '#83a598',
      \'#d3869b', '#8ec07c', '#fe8019', '#FBF1C7' ]

highlight Terminal guibg='#282828'
highlight Terminal guifg='#ebdbb2'

nnoremap <Leader>a      :call SyntaxAttr()<CR>
"hi YcmErrorSection cterm=undercurl ctermfg=red
"hi YcmWarningSection cterm=undercurl ctermfg=yellow
" These are common escape sequences for undercurl

" Let the undercurl escape in terminal
let &t_Cs = "\e[4:3m" " Start undercurl
let &t_Ce = "\e[4:0m" " End underline/undercurl

" Enable highlighting of C++11 attributes
"let g:cpp_attributes_highlight = 1
" Put all standard C and C++ keywords under Vim's highlight group 'Statement'
" (affects both C and C++ files)
"let g:cpp_simple_highlight = 1
" Highlight struct/class member variables (affects both C and C++ files)
"let g:cpp_member_highlight = 1
"au FileType cpp let b:c_no_curly_error=1
autocmd FileType cpp let b:c_no_curly_error = 1

" Tell Vim where the build directory is
let g:build_dir = 'build'

" Use the build directory for the make command
"let &makeprg = 'make -C ' . g:build_dir
let &makeprg = 'cd ' . g:build_dir . ' && make'

let g:asyncrun_open = 10
command! -bang -nargs=* -complete=file Make AsyncRun -program=make @<args>
nnoremap<F8> :if g:asyncrun_status != 'running'<bar>
      \if &modifiable<bar>
        \update<bar>
      \endif<bar>
        \exec 'Make'<bar>
      \else<bar>
        \AsyncStop<bar>
      \endif<CR>
nnoremap<S-F8> :cclose<CR>
"set errorformat=%f:%l:%c:\ %t%*[^:]:\ %m,%f:%l:\ %t%*[^:]:\ %m
"set errorformat=%f:%l:%m
"set errorformat=%f\|%l\ col\ %c\ %t\|%m,%f\|%l\ col\ %c\ note\|%m,%f\|%l\ col\ %c\ %t%m,%Z%I\|%m,%-G||%m,%-G%m
"set errorformat=%*[^\"]\"%f\"%*\\D%l:\ %m,\"%f\"%*\\D%l:\ %m,%-G%f:%l:\ (Each\ undeclared\ identifier\ is\ reported\ only\ once,%-G%f:%l:\ for\ each\ function\ it\ appears\ in.),%-GIn\ file\ included\ from\ %f:%l:%c:,%-GIn\ file\ included\ from\ %f:%l:%c,%-GIn\ file\ included\ from\ %f:%l,%-Gfrom\ %f:%l:%c,%-Gfrom\ %f:%l,%f:%l:%c:%m,%f(%l):%m,%f:%l:%m,\"%f\"\\,\ line\ %l%*\\D%c%*[^\ ]\ %m,%D%*\\a[%*\\d]:\ Entering\ directory\ `%f',%X%*\\a[%*\\d]:\ Leaving\ directory\ `%f',%D%*\\a:\ Entering\ directory\ `%f',%X%*\\a:\ Leaving\ directory\ `%f',%DMaking\ %*\\a\ in\ %f,%f\|%l\|\ %m
" CMake Parser
" Call stack entries
au FileType c,cpp :compiler gcc

"let $FZF_DEFAULT_OPTS="--preview-window 'right:57%' --preview 'bat --style=numbers --line-range :300 {}'
"\ --bind ctrl-y:preview-up,ctrl-e:preview-down,
"\ctrl-b:preview-page-up,ctrl-f:preview-page-down,
"\ctrl-u:preview-half-page-up,ctrl-d:preview-half-page-down, "\shift-up:preview-top,shift-down:preview-bottom,
"\alt-up:half-page-up,alt-down:half-page-down"
"

" Vimspector
nnoremap <Leader>db :call vimspector#Launch()<CR>

function! PromptAndAsyncRun()
  let l:input_command = input('Enter a command: ', '', 'shellcmd')

  if !empty(l:input_command)
    execute 'AsyncRun ' . l:input_command
  endif
endfunction
nnoremap <Leader>sl :call PromptAndAsyncRun()<CR>

" Adjust the height of quickfix window
au FileType qf call AdjustWindowHeight(10, 18)
function! AdjustWindowHeight(minheight, maxheight)
  exe max([min([line("$"), a:maxheight]), a:minheight]) . "wincmd _"
endfunction

" Adjust the size of the window
if has('gui_running')
  nnoremap <C-=> <C-W>+
  nnoremap <C-_> <C-W>-
  nnoremap <C-.> <C-W>>
  nnoremap <C-,> <C-W><
endif

" vim-fontsize for gvim
let g:fontsize#timeoutlen = 2000

if !empty($SSH_CLIENT)
  highlight YcmWarningSection cterm=undercurl gui=undercurl guifg=#fabd2f guibg=NONE
  highlight YcmErrorSection cterm=undercurl gui=undercurl guifg=#fb4934 guibg=NONE
endif
"highlight YcmErrorSection cterm=undercurl, gui=undercurl guifg=#CF0F47
"highlight YcmWarningSection cterm=undercurl, gui=undercurl guifg=#EF7722
